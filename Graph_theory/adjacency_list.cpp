//#include "Graph_theory.h"
//
//
//int main() {
//	// Для корректного отображение кириллицы в консоли
//	setlocale(LC_ALL, "Russian");
//	// Создаём поток ввода, открываем файл, соответствующий выбранному способу задания графа
//	ifstream in("data/graph_theory/graph_adjacency_list.txt");
//	// Проверка, открылся ли файл (необязательно, но желательно)
//	if (!in.is_open()) {
//		cout << "File not found\n";
//		// Exit - плохая функция, лучше было бы написать всё остальное под else
//		exit(-1);
//	}
//	// Строка - буфер, просто промежуточный контейнер между файлом и int'овской переменной
//	// (считать сразу в контейнер типа int нельзя)
//	string buffer = "";
//	// Считываем количество вершин
//	in >> buffer;
//	int n = stoi(buffer);
//	List_adjacency* list = new List_adjacency(n);
//	// Длина очередного списка смежности для очередной вершины 
//	int row_len;
//	for (int i = 0; i < n; i++) {
//		/* Теперь уже используем getline, нужно его синхронизировать
//		   напоминание: конструкция do-while отличается от обычного while только тем,
//		   что в do-while сначала выполняется шаг, затем проверяется условие */
//		do { getline(in, buffer); } while (buffer == "");
//		/*Теперь нужно строку из чисел, разделённых пробелами, привести к массиву int
//		  .split или подобных "магических" методов в плюсах нет, поэтому вручную.
//		  Для начала посчитаем количество элементов в списке, оно равно количеству пробелов + 1 */
//		row_len = count(' ', buffer) + 1;
//		// Теперь мы можем выделить нужное количество памяти и заполнить массив
//		int* row = new int[row_len];
//		// Количество уже заполненных элементов массива row
//		int k = 0;
//		// Очередной элемент массива в виде string, длина строки buffer
//		string elem = ""; int len = buffer.length();
//		for (int j = 0; j < len; j++) {
//			/* Добавляем в elem цифры очередного числа до тех пор, пока не найдём
//			   разделитель (пробел). Когда нашли - привели к int'у, записали в список
//			   и не забыли сделать elem снова пустым (для записи следующего числа) */
//			if (buffer[j] == ' ') {
//				row[k++] = stoi(elem);
//				elem = "";
//			}
//			else elem += buffer[j];
//		}
//		// Не забываем про последний элемент, после которого нет пробела
//		row[k] = stoi(elem);
//		// Добавляем ряд в экземпляр класса и очищаем выделенную память
//		// (ряд теперь хранится внутри экземпляра класса)
//		list->add_list(i, row_len, row);
//		delete[] row;
//	}   
//	// Поскольку мы всё считали из файла ввода, нужно закрыть поток
//	in.close();
//	// Спрашиваем у пользователя, в какую форму нужно перевести список (списков) смежности
//	int transform_to; 
//	cout << "Выберите, в какое представление преобразовать список списков смежности:\n" <<
//		"1 если в матрицу инцидентности, 2 если в массив рёбер: ";
//	cin >> transform_to;
//	if (transform_to == 2) {
//		vector<vector<int>> res = list->to_edges_array();
//		ofstream out("data/out.txt");
//		// Проверка, открылся ли файл (необязательно, но желательно)
//		if (!out.is_open()) {
//			cout << "File not found\n";
//			// Exit - плохая функция, лучше было бы написать всё остальное под else
//			exit(-1);
//		}
//		// Чтобы не вычислять на каждом шаге цикла
//		int len = res.size();
//		out << to_string(len) << endl;
//		for (int i = 0; i < len; i++) {
//			out << to_string(res[i][0]) << ' ' << to_string(res[i][1]) << endl;
//		}
//		cout << "Успешно!\n";
//		out.close();
//	}
//	return 0;
//}