//#include "Graph_theory.h"
//
//
//int main() {
//	// Чтобы кириллица корректно отображалась в консоли
//	setlocale(LC_ALL, "Russian");
//	// Создаём поток ввода, открываем файл, соответствующий выбранному способу задания графа
//	ifstream in("data/graph_theory/graph_edges_array.txt");
//	// Проверка, открылся ли файл (необязательно, но желательно)
//	if (!in.is_open()) {
//		cout << "File not found\n";
//		// Exit - плохая функция, лучше было бы написать всё остальное под else
//		exit(-1);
//	}
//	// Строка - буфер, просто промежуточный контейнер между файлом и int'овской переменной
//	// (считать сразу в контейнер типа int нельзя)
//	string buffer = "";
//	// Считываем число рёбер сначала в строку-буфер
//	in >> buffer;
//	// Затем с помощью stoi (string-to-integer) приводим строку к целочисленному типу
//	int amount_of_edges = stoi(buffer);
//	// Создаём двумерный массив, выделяем память
//	int** edges_array = new int* [amount_of_edges];
//	for (int i = 0; i < amount_of_edges; i++) {
//		// Поскольку ребро всегда между двумя вершинами, тут просто 2
//		edges_array[i] = new int[2];
//		/* Конструкция "in >>" считывает из потока до пробела (или переноса строки)
//			поэтому, если у нас номера вершин ребра записаны через пробел, нужно дважды
//			считать номер очередной вершины в буфер, привести его к int и записать
//			в ячейку очередного ребра. Можно было бы использовать getline, считывающий
//			сразу всю строку, но нужно было бы заниматься синхронизацией (первый getline
//			будет пустым) и разбивать строку на две через пробел (используя substr и find) */
//		in >> buffer; edges_array[i][0] = stoi(buffer) - 1;
//		in >> buffer; edges_array[i][1] = stoi(buffer) - 1;
//		// (вычитаем единицу, т. к. "человеческая" нумерация с 1)
//	}
//}